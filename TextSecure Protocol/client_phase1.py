# -*- coding: utf-8 -*-
"""Client.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IEQh2jkEpacbHYGX1TsDwCs9rATcWkqQ
"""
"""
!pip install ecpy
!pip install sympy
!pip install pyprimes
!pip install pycryptodome
"""
import json
import re
from Crypto.Util.Padding import unpad
from Crypto.Util.Padding import pad
from Crypto import Random
from Crypto.Cipher import AES
import requests
from Crypto.Hash import SHA3_256
import math
import timeit
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve, Point
import Crypto.Random.random
API_URL = 'http://cryptlygos.pythonanywhere.com'

stuID = 24001
seed(13)
E = Curve.get_curve('secp256k1')
n = E.order
p = E.field
P = E.generator
a = E.a
b = E.b
print("Base point:\n", P)
print("p :", p)
print("a :", a)
print("b :", b)
print("n :", n)
print("P :", P)
# HERE CREATE A LONG TERM KEY
#
#sA = Crypto.Random.random.randint(2, n-1)
sL = randint(2, n-1)
lkey = sL * P
print("sA :", sL)
print("LKEY :", lkey)
print('LKEY.X: ', lkey.x)
print('LKEY.Y: ', lkey.y)

"""
Signature generation: Let m be an arbitrary length message. The signature is computed
as follows:
1. k ← Zn, (i.e., k is a random integer in [1, n − 2]).
2. R = k · P
3. r = R.x (mod n), where R.x is the x coordinate of R
4. h = SHA3 256(m + r) (mod n)
5. s = (sA · h + k) (mod n)
6. The signature for m is the tuple (h, s).
"""

k = randint(1, n-2)
print("k: ", k)
R = k * P
print("R: ", R)
print("Rx: ", R.x)
r = R.x % n
print("r: ", r)
h_ = SHA3_256.new(str.encode(str(stuID)) +
                  r.to_bytes((r.bit_length()+7)//8, byteorder='big'))
str.encode(str(stuID))
h = int.from_bytes(h_.digest(), byteorder='big') % n
print("h: ", h)
s = (sL * h + k) % n
print("s: ", s)

try:
    # REGISTRATION
    mes = {'ID': stuID, 'h': h, 's': s, 'LKEY.X': lkey.x, 'LKEY.Y': lkey.y}
    response = requests.put('{}/{}'.format(API_URL, "RegStep1"), json=mes)
    if ((response.ok) == False):
        raise Exception(response.json())
    print(response.json())

    print("Enter verification code which is sent to you: ")
    code = int(input())

    mes = {'ID': stuID, 'CODE': code}
    response = requests.put('{}/{}'.format(API_URL, "RegStep3"), json=mes)
    if ((response.ok) == False):
        raise Exception(response.json())
    print(response.json())
except Exception as e:
    print(e)

# HERE GENERATE A EPHEMERAL KEY
sA = randint(2, n-1)
ekey = sA * P
print("sA = ", sA)
print("EKEY = ", ekey)

try:
    # STS PROTOCOL
    mes = {'ID': stuID, 'EKEY.X': ekey.x, 'EKEY.Y': ekey.y}
    response = requests.put('{}/{}'.format(API_URL, "STSStep1&2"), json=mes)
    if ((response.ok) == False):
        raise Exception(responce.json())
    res = response.json()
    print(res)
except Exception as e:
    print(e)

skey_x = res['SKEY.X']
skey_y = res['SKEY.Y']
print("SKEY.X = ", skey_x)
print("SKEY.Y = ", skey_y)

Qb = Point(skey_x, skey_y, E)
print("Qb = ", Qb)
T = sA * Qb
print("T = ", T)
U = str(T.x) + str(T.y) + "BeYourselfNoMatterWhatTheySay"
print("U = ", U)
K = SHA3_256.new(str.encode(U))
print("K = ", K.digest())

W1 = str(ekey.x) + str(ekey.y) + str(Qb.x) + str(Qb.y)
print("W1 = ", W1)

k = randint(1, n-2)
print("k: ", k)
R = k * P
print("R: ", R)
print("Rx: ", R.x)
r = R.x % n
print("r: ", r)
print()
h_ = SHA3_256.new(str.encode(str(W1)) +
                  r.to_bytes((r.bit_length()+7)//8, byteorder='big'))
h = int.from_bytes(h_.digest(), byteorder='big') % n
print("h: ", h)
s = (sL * h + k) % n
print("s: ", s)

plaintext = "s" + str(s) + "h" + str(h)
print("plaintext = ", plaintext)
K_ = K.digest()
cipher = AES.new(K_, AES.MODE_CTR)
Y1 = cipher.encrypt(str.encode(plaintext))
print("Y1 = ", Y1)
ctext = cipher.nonce + Y1
ctext = int.from_bytes(ctext, byteorder='big')
print("ctext = ", ctext)

try:
    # Send encrypted-signed keys and retrive server's signed keys
    mes = {'ID': stuID, 'FINAL MESSAGE': ctext}
    response = requests.put('{}/{}'.format(API_URL, "STSStep4&5"), json=mes)
    if((response.ok) == False):
        raise Exception(response.json())
    ctext = response.json()
    print("ctext = ", ctext)
except Exception as e:
    print(e)

ctext_ = ctext.to_bytes((ctext.bit_length() + 7) // 8, 'big')
cipher = AES.new(K_, AES.MODE_CTR, nonce=ctext_[0:8])
dtext_ = cipher.decrypt(ctext_[8:])
dtext = dtext_.decode('UTF-8')
print("Decrypted text: ", dtext)

QSer_long = Point(0xc1bc6c9063b6985fe4b93be9b8f9d9149c353ae83c34a434ac91c85f61ddd1e9,
                  0x931bd623cf52ee6009ed3f50f6b4f92c564431306d284be7e97af8e443e69a8c, E)

W2 = str(Qb.x) + str(Qb.y) + str(ekey.x) + str(ekey.y)
print("W2 = ", W2)

s_ = int(dtext[1:dtext.find('h')])
print("s =", s_)
h_ = int(dtext[dtext.find('h')+1:])
print("h =", h_)

Vbig = (s_ * P) - (h_ * QSer_long)
print("V = ", Vbig)

v = Vbig.x % n
print("v = ", v)
h_prime_ = SHA3_256.new(str.encode(str(W2)) +
                        v.to_bytes((v.bit_length()+7)//8, byteorder='big'))
h_prime = int.from_bytes(h_prime_.digest(), byteorder='big') % n
print("h' = ", h_prime)
print()
if (h_prime == h_):
    print("Signature verifies :)")
else:
    print("Signature does not verifies :(")

try:
    mes_ = {'ID': stuID}
    response = requests.get('{}/{}'.format(API_URL, "STSStep6"), json=mes_)
    ctext_mes = response.json()
    print(ctext_mes)
except Exception as e:
    print(e)

ctext_m = ctext_mes.to_bytes((ctext_mes.bit_length() + 7) // 8, 'big')
cipher = AES.new(K_, AES.MODE_CTR, nonce=ctext_m[0:8])
dtext_mes = cipher.decrypt(ctext_m[8:])
dtext_m = dtext_mes.decode('UTF-8')
print("Decrypted text: ", dtext_m)

RAND = int(dtext_m[dtext_m.find('.')+2:])
print("RAND = ", RAND)
W3 = dtext_m[:dtext_m.find('.')+1] + " " + str(RAND+1)
print("W3 = ", W3)

cipher_ = AES.new(K_, AES.MODE_CTR)
mes_to_server = cipher_.encrypt(str.encode(W3))

ct = cipher_.nonce + mes_to_server
ct = int.from_bytes(ct, byteorder='big')
print("ct = ", ct)

try:
    mes = {'ID': stuID, 'ctext': ct}
    response = requests.put('{}/{}'.format(API_URL, "STSStep7&8"), json=mes)
    ctext_2 = response.json()
    print(ctext_2)
except Exception as e:
    print(e)

ctext_m_2 = ctext_2.to_bytes((ctext_2.bit_length() + 7) // 8, 'big')
cipher_2 = AES.new(K_, AES.MODE_CTR, nonce=ctext_m_2[0:8])
dtext_mes_2 = cipher_2.decrypt(ctext_m_2[8:])
dtext_m_2 = dtext_mes_2.decode('UTF-8')
print("Decrypted text: ", dtext_m_2)
